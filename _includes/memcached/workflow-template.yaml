---
# {% raw %} The workflow template that does the "heavy lifting"
apiVersion: argoproj.io/v1alpha1
kind: WorkflowTemplate
metadata:
  name: memcached-deploy-workflow-template
spec:
  # See the `main` template below: this gets executed
  entrypoint: main
  # Use the service account with sufficient rights to deploy
  serviceAccountName: memcached-sa
  ttlStrategy:
    secondsAfterCompletion: 300
  # Garbage collection settings for clearing up old pods
  podGC:
    strategy: OnPodSuccess

  # Global Workflow parameters, passed/overridden from the Sensor
  arguments:
    parameters:
      # Injected by Sensor workflow
      - name: message
        default: ""
      # Injected by Sensor workflow
      - name: operation
        default: ADD
      # Overridden by Sensor workflow
      - name: replicas
        value: "1"
      - name: script
        valueFrom:
          configMapKeyRef:
            name: memcached-cm
            key: main.py

  templates:
    # A simple logging container template - we'll use this to debug
    - name: log
      inputs:
        parameters:
          - name: content
      container:
        name: simple-logger
        image: ubuntu:latest
        command:
          - echo
        args:
          - "{{inputs.parameters.content}}"

    # The actual "business logic" for our operator.
    # As tutorials go, it's a bit contrived - there's very little
    # action going on
    - name: operator-logic
      inputs:
        parameters:
          - name: deployment-manifest
      container:
        name: python-operator-logic
        image: python:3.10-slim
        command:
          - python3
          - -c
          - "{{workflow.parameters.script}}"
          - --deployment={{inputs.parameters.deployment-manifest}}
          - --replicas={{workflow.parameters.replicas}}
      outputs:
        parameters:
          - name: result
            valueFrom:
              path: /output-manifest.json

    - name: operation-mapping
      script:
        image: python:3.10-slim
        command:
          - python3
        # The "operations" from our event source differ from the ones used in the
        # deployment syntax - we need to map from one to the other
        source: |
          mapping = {
            "ADD": "apply",
            "UPDATE": "apply",
            "DELETE": "delete",
          }
          print(mapping["{{workflow.parameters.operation}}"])

    - name: deploy
      inputs:
        parameters:
          - name: action
          - name: manifest
      resource:
        action: "{{inputs.parameters.action}}"
        manifest: "{{inputs.parameters.manifest}}"

    # This is the actual entrypoint for our workflow
    # It takes care of the execution flow
    - name: main
      steps:
        - - name: log-message
            # Uses the "log" template below
            template: log
            arguments:
              parameters:
                - name: content
                  value: "{{workflow.parameters.message}}"

        - - name: log-operation
            # Again: uses the "log" template below so we only need to define once
            template: log
            arguments:
              parameters:
                - name: content
                  value: "{{workflow.parameters.operation}}"

        - - name: parameterize-replicas
            template: operator-logic
            arguments:
              parameters:
                - name: manifest
                  # Since the value of a parameter is always a string:
                  # the "pipe" | symbol denotes yaml multi-line text
                  value: |
                    apiVersion: apps/v1
                    kind: Deployment
                    metadata:
                      name: memcached-deployment
                      labels:
                        app: memcached
                    spec:
                      # This setting will be reconfigured by our operator!
                      replicas: 1
                      selector:
                        matchLabels:
                          app: memcached
                      template:
                        metadata:
                          labels:
                            app: memcached
                        spec:
                          containers:
                            - name: memcached
                              command:
                                - memcached
                                - -m=64
                                - -o
                                - modern
                                - -v
                              image: "docker.io/memcached:1.4.36-alpine"
                              ports:
                                - containerPort: 11211

        - - name: log-result
            template: log
            arguments:
              parameters:
                - name: content
                  value: "{{steps.parameterize-replicas.outputs.result}}"

        - - name: map-operation-to-action
            # Calls the actual operator "business logic" part
            template: operation-mapping

        - - name: log-action
            template: log
            arguments:
              parameters:
                - name: content
                  value: "{{steps.map-operation-to-action.outputs.result}}"

        - - name: deploy-memcached
            template: deploy
            arguments:
              parameters:
                - name: action
                  value: "{{steps.map-operation-to-action.outputs.result}}"
                - name: manifest
                  value: "{{steps.parameterize-replicas.outputs.result}}"
# Done! {% endraw %}
